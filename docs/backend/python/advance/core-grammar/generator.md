---
title: 生成器
createTime: 2026/02/05 10:24:12
permalink: /backend/python/advance-core-grammar/generator/
badge: 推导式
---


## 核心原理

基于**惰性求值**（按需生成数据），无需预生成所有数据，仅记录生成规则，通过`yield`关键字实现函数的**暂停 / 恢复执行**，是**时间换空间**的核心方案，内存占用远低于列表。


## 核心形式

``` python
# 形式1：生成器表达式 → () 替代列表推导式的 []，极简语法，适合简单逻辑
# 对比：列表推导式一次性生成所有数据，占满内存；生成器仅记录规则，内存占用KB级
list_data = [x * 2 for x in range(1000000)]  # 占用约800MB内存
gen_data = (x * 2 for x in range(1000000))   # 占用约几十KB内存

# 形式2：生成器函数 → yield 逐个返回结果，支持复杂业务逻辑，适合自定义生成规则
# 示例：生成斐波那契数列（无限序列/大数据序列首选）
def gen_fib(n):
    """生成前n个斐波那契数"""
    a, b = 0, 1
    for _ in range(n):
        yield a  # 暂停执行，返回当前值；下次调用从下一行继续
        a, b = b, a + b

# 生成器使用：通过next()或for循环迭代，一次生成一个数据
fib_gen = gen_fib(5)
print(next(fib_gen))  # 0
print(next(fib_gen))  # 1
for num in fib_gen:
    print(num)        # 1, 2, 3（剩余元素）
```


## 核心优势

- **极低内存占用**，适合大数据集处理、流式数据解析（如日志文件、网络流）；
- 支持无限序列（如斐波那契、自增 ID），列表无法实现；
- 函数执行可暂停，**适合分步执行**的场景。


## 核心限制与避坑

- 生成器仅可迭代一次，数据**生成后即销毁**，二次迭代无结果；
- 无法通过`len()`获取长度，需手动迭代计数；
- 生成器内的**异常需在迭代时捕获**，定义时不触发。


## 核心场景

大数据集处理、流式数据解析、爬虫分页数据获取、避免一次性加载数据导致的内存溢出。