---
title: 组件通信方式
createTime: 2025/07/18 09:50:49
permalink: /frontend/vue3/data-prop/
---

## 概述

此文章主要整理下vue项目中不同场景下，采用交互方式的选择。

## 不同场景

### 父子组件通信（props+emit）

**parent.vue**
- ``:message`` v-bind绑定参数传递到子组件
- ``@update`` @绑定事件传递到子组件
- ``childRef`` 通过childRef调用子组件暴露的方法

::: tip childRef

调用子组件Ref模板的ts类型在vue3.5做了优化，[模板引用类型](https://cn.vuejs.org/guide/typescript/composition-api#typing-template-refs)

**vue3.5前**
``` ts
type ChildCompType = InstanceType<typeof ChildComp>;
const childRef = ref<ChildCompType | null>(null);
```

**vue3.5+**
``` ts
const childRef = useTemplateRef("childRef");
```
:::

**child.vue**
- ``defineProps`` 接收父组件的传递值
- ``defineEmits`` 回调父组件的函数

::: warning $parent调用

``getCurrentInstance()?.proxy?.$parent.xxx``调用父级的函数（不推荐）

建议采用emit的方式实现

:::

::: code-tabs
@tab parent.vue
``` vue
<script setup lang="ts">
import ChildComp from "./child.vue";
import { ref, useTemplateRef } from "vue";
defineOptions({
  name: "ParentComp",
});

const message = ref<string>("message");

// type ChildCompType = InstanceType<typeof ChildComp>;
// const childRef = ref<ChildCompType | null>(null);

// useTemplateRef vue3.5+
const childRef = useTemplateRef("childRef");

const handleUpdate = (newValue: string) => {
  message.value = newValue;
  // 调用子组件的函数
  childRef.value?.childClick();
};
</script>

<template>
  <button @click="message = 'message'">reset message</button>
  <!-- message传递， @update接收 -->
  <ChildComp
    ref="childRef"
    :message="message"
    @update="handleUpdate"
  ></ChildComp>
</template>

<style scoped></style>
```

@tab child.vue
``` vue
<script setup lang="ts">
defineOptions({
  name: "ChildComp",
});
// defineProps接收
const props = defineProps<{
  message: string;
}>();

// defineEmits回调
const emit = defineEmits<{ update: [value: string] }>();

const handleClick = (value: string) => {
  emit("update", value);
};

const childClick = () => {
  console.log("child is click");
};
// setup中需要暴露才能读取
defineExpose({ childClick });
</script>

<template>
  <button @click="handleClick('update message')">update message</button>
  <div>{{ props.message }}</div>
</template>

<style scoped></style>
```
:::

---

### 祖孙组件通信（provide+inject）

- ``provide`` 向子组件和孙组件[依赖注入](https://cn.vuejs.org/guide/components/provide-inject.html)
- ``inject`` 提取依赖进行操作

::: info

项目中==provide依赖使用频繁==，key建议采用[Symbol](https://cn.vuejs.org/guide/components/provide-inject.html#working-with-symbol-keys)

TS开发[标注类型](https://cn.vuejs.org/guide/typescript/composition-api.html#typing-provide-inject)文档

:::

::: code-tabs

@tab parent.vue
``` vue
<script setup lang="ts">
import ChildComp from "./child.vue";
import { provide, ref } from "vue";
defineOptions({
  name: "ParentComp",
});
const message = ref<string>("hello");

provide("message", message);
</script>

<template>
  <input v-model="message" />
  <ChildComp></ChildComp>
</template>

<style scoped></style>
```

@tab child.vue
``` vue
<script setup lang="ts">
import GrandChildComp from "./grandChild.vue";
defineOptions({
  name: "ChildComp",
});
</script>

<template>
  <GrandChildComp></GrandChildComp>
</template>

<style scoped></style>
```

@tab grandChild.vue
``` vue
<script setup lang="ts">
import { inject, type Ref } from "vue";
defineOptions({
  name: "GrandChildComp",
});

const message = inject<Ref<string>>("message");
// 双向绑定的参数在孙组件也可以修改
if (message) {
  message.value = "update";
}
</script>

<template>
  <div>{{ message }}</div>
</template>

<style scoped></style>
```

:::

---

### 兄弟组件通信(mitt)

方式一：通过父组件定义参数和函数，传递到兄弟组件进行互通（根据场景使用，个别情况有点累赘）

方式二：通过[mitt插件](https://www.npmjs.com/package/mitt?activeTab=readme)注册事件监听

::: code-tabs

@tab parent.vue
``` vue
<script setup lang="ts">
import ChildComp from "./child.vue";
import Child1Comp from "./child1.vue";
defineOptions({
  name: "ParentComp",
});
</script>

<template>
  <ChildComp></ChildComp>
  <Child1Comp></Child1Comp>
</template>

<style scoped></style>
```

@tab eventBus.ts
``` ts
import mitt from "mitt";

const emitter = mitt();

export default emitter;
```

@tab child.vue
``` vue
<script setup lang="ts">
import eventBus from "./eventBus";
defineOptions({
  name: "ChildComp",
});
// 注册
eventBus.on("test", (e) => console.log("test", e));
</script>

<template>
  <div></div>
</template>

<style scoped></style>
```

@tab child1.vue
``` vue
<script setup lang="ts">
import eventBus from "./eventBus";
defineOptions({
  name: "Child1Comp",
});
// 触发
eventBus.emit("test", { a: "b" });
</script>

<template>
  <div></div>
</template>

<style scoped></style>
```
:::

## 其他通信

### 自定义hooks方法（一般不推荐）

通过自定义的hooks方法，在使用到相关业务的组件中引用。

缺点：sharedState在内存中存留。

``` js title="useSharedState.js"
import { reactive, ref } from 'vue'

// 在模块级别创建共享状态，而不是在函数内部
const sharedState = reactive({
  count: 0
})

export const useSharedState = () => {
  const increment = () => {
    sharedState.count++
  }

  return {
    sharedState,
    increment
  }
}
```

### pinia（状态共享）

pinia插件全局组件数据状态共享,适合在多场景中使用。

``` ts title="useAuthStore.ts"
import { ref } from 'vue';
import { defineStore } from 'pinia';
export const useAuthStore = defineStore('auth',()=>{
  const token = ref('');
  const setToken = (token:string)=>{
    token.value = token;
  }
  return {token, setToken};
})
```

